{"version":3,"sources":["webpack:///static/js/10.90dc81b14450100c0a92.js","webpack:///./~/tinymce/plugins/spellchecker/index.js","webpack:///./~/tinymce/plugins/spellchecker/plugin.js"],"names":["webpackJsonp","BT+F","module","exports","__webpack_require__","yTvn","domGlobals","isContentEditableFalse","node","nodeType","contentEditable","Plugin","suggestionsMenu","Cell","initial","value","get","set","v","clone","global","tinymce","util","Tools","resolve","hasProPlugin","editor","test","settings","plugins","window","console","log","DetectProPlugin","getLanguages","getParam","getLanguage","defaultLanguage","getRpcUrl","getSpellcheckerCallback","getSpellcheckerWordcharPattern","defaultPattern","RegExp","Settings","global$1","global$2","global$3","fireSpellcheckStart","fire","fireSpellcheckEnd","Events","DomTextMatcher","createMatch","m","data","Error","start","index","end","length","text","getText","txt","hiddenTextElementsMap","nodeName","blockElementsMap","shortEndedElementsMap","firstChild","nextSibling","stepThroughMatches","matches","replaceFn","startNode","endNode","startNodeIndex","endNodeIndex","matchLocation","innerNodes","atIndex","curNode","matchIndex","slice","sort","a","b","shift","out","push","match","parentNode","genReplacer","callback","makeReplacementNode","fill","stencil","cloneNode","setAttribute","appendChild","dom","doc","createTextNode","range","before","after","node_1","substring","insertBefore","el","removeChild","elA","i","l","innerNode","innerEl","replaceChild","elB","unwrapElement","element","hasClass","elm","className","indexOf","getWrappersByIndex","elements","getElementsByTagName","wrappers","dataIndex","getAttribute","filter","filteredMatches","each","this","wrap","find","regex","exec","unwrap","matchFromElement","elementFromMatch","add","substr","rangeFromMatch","rng","createRng","setStartBefore","setEndAfter","replace","deleteContents","insertNode","reset","splice","schema","getBlockElements","getWhiteSpaceElements","getShortEndedElements","getTextMatcher","textMatcherState","textMatcher","getBody","isEmpty","obj","_","defaultSpellcheckCallback","pluginUrl","currentLanguageState","method","doneCallback","errorCallback","lang","postData","key","encodeURIComponent","send","url","toAbsolute","type","content_type","success","result","JSON","parse","error","message","translate","sendRpcCall","name","successCallback","userSpellcheckCallback","call","spellchecker","spellcheck","startedState","lastSuggestionsState","finish","notificationManager","open","setProgressState","markErrors","focus","checkIfFinished","select","addToDictionary","word","spans","remove","ignoreWord","all","selection","collapse","span","bookmark","getBookmark","moveToBookmark","getElmIndex","findSpansByIndex","nodes","toArray","nodeIndex","toString","suggestions","hasDictionarySupport","words","dictionary","create","Actions","getWordCharPattern","Api","register","addCommand","Commands","buildMenuItems","listName","languageValues","items","languageValue","selectable","updateSelection","e","selectedLanguage","control","ctrl","active","getItems","map","split","langPair","register$1","languageMenuItems","startSpellchecking","buttonArgs","tooltip","onclick","onPostRender","on","menu","onshow","onselect","addButton","addMenuItem","context","self","Buttons","global$4","global$5","showSuggestions","suggestion","insertContent","encode","apply","onautohide","target","preventDefault","onhide","renderTo","document","body","pos","DOM","getPos","getContentAreaContainer","targetPos","root","getRoot","x","ownerDocument","documentElement","scrollLeft","y","scrollTop","moveTo","offsetHeight","setup","setRng","SuggestionsMenu"],"mappings":"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","file":"static/js/10.90dc81b14450100c0a92.js","sourcesContent":["webpackJsonp([10],{\n\n/***/ \"BT+F\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Exports the \"spellchecker\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/spellchecker')\n//   ES2015:\n//     import 'tinymce/plugins/spellchecker'\n__webpack_require__(\"yTvn\");\n\n/***/ }),\n\n/***/ \"yTvn\":\n/***/ (function(module, exports) {\n\n(function () {\nvar spellchecker = (function (domGlobals) {\n    'use strict';\n\n    var Cell = function (initial) {\n      var value = initial;\n      var get = function () {\n        return value;\n      };\n      var set = function (v) {\n        value = v;\n      };\n      var clone = function () {\n        return Cell(get());\n      };\n      return {\n        get: get,\n        set: set,\n        clone: clone\n      };\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    var hasProPlugin = function (editor) {\n      if (/(^|[ ,])tinymcespellchecker([, ]|$)/.test(editor.settings.plugins) && global.get('tinymcespellchecker')) {\n        if (typeof domGlobals.window.console !== 'undefined' && domGlobals.window.console.log) {\n          domGlobals.window.console.log('Spell Checker Pro is incompatible with Spell Checker plugin! ' + 'Remove \\'spellchecker\\' from the \\'plugins\\' option.');\n        }\n        return true;\n      } else {\n        return false;\n      }\n    };\n    var DetectProPlugin = { hasProPlugin: hasProPlugin };\n\n    var getLanguages = function (editor) {\n      var defaultLanguages = 'English=en,Danish=da,Dutch=nl,Finnish=fi,French=fr_FR,German=de,Italian=it,Polish=pl,Portuguese=pt_BR,Spanish=es,Swedish=sv';\n      return editor.getParam('spellchecker_languages', defaultLanguages);\n    };\n    var getLanguage = function (editor) {\n      var defaultLanguage = editor.getParam('language', 'en');\n      return editor.getParam('spellchecker_language', defaultLanguage);\n    };\n    var getRpcUrl = function (editor) {\n      return editor.getParam('spellchecker_rpc_url');\n    };\n    var getSpellcheckerCallback = function (editor) {\n      return editor.getParam('spellchecker_callback');\n    };\n    var getSpellcheckerWordcharPattern = function (editor) {\n      var defaultPattern = new RegExp('[^' + '\\\\s!\"#$%&()*+,-./:;<=>?@[\\\\]^_{|}`' + '\\xA7\\xA9\\xAB\\xAE\\xB1\\xB6\\xB7\\xB8\\xBB' + '\\xBC\\xBD\\xBE\\xBF\\xD7\\xF7\\xA4\\u201D\\u201C\\u201E\\xA0\\u2002\\u2003\\u2009' + ']+', 'g');\n      return editor.getParam('spellchecker_wordchar_pattern', defaultPattern);\n    };\n    var Settings = {\n      getLanguages: getLanguages,\n      getLanguage: getLanguage,\n      getRpcUrl: getRpcUrl,\n      getSpellcheckerCallback: getSpellcheckerCallback,\n      getSpellcheckerWordcharPattern: getSpellcheckerWordcharPattern\n    };\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.util.URI');\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.util.XHR');\n\n    var fireSpellcheckStart = function (editor) {\n      return editor.fire('SpellcheckStart');\n    };\n    var fireSpellcheckEnd = function (editor) {\n      return editor.fire('SpellcheckEnd');\n    };\n    var Events = {\n      fireSpellcheckStart: fireSpellcheckStart,\n      fireSpellcheckEnd: fireSpellcheckEnd\n    };\n\n    function isContentEditableFalse(node) {\n      return node && node.nodeType === 1 && node.contentEditable === 'false';\n    }\n    var DomTextMatcher = function (node, editor) {\n      var m, matches = [], text;\n      var dom = editor.dom;\n      var blockElementsMap, hiddenTextElementsMap, shortEndedElementsMap;\n      blockElementsMap = editor.schema.getBlockElements();\n      hiddenTextElementsMap = editor.schema.getWhiteSpaceElements();\n      shortEndedElementsMap = editor.schema.getShortEndedElements();\n      function createMatch(m, data) {\n        if (!m[0]) {\n          throw new Error('findAndReplaceDOMText cannot handle zero-length matches');\n        }\n        return {\n          start: m.index,\n          end: m.index + m[0].length,\n          text: m[0],\n          data: data\n        };\n      }\n      function getText(node) {\n        var txt;\n        if (node.nodeType === 3) {\n          return node.data;\n        }\n        if (hiddenTextElementsMap[node.nodeName] && !blockElementsMap[node.nodeName]) {\n          return '';\n        }\n        if (isContentEditableFalse(node)) {\n          return '\\n';\n        }\n        txt = '';\n        if (blockElementsMap[node.nodeName] || shortEndedElementsMap[node.nodeName]) {\n          txt += '\\n';\n        }\n        if (node = node.firstChild) {\n          do {\n            txt += getText(node);\n          } while (node = node.nextSibling);\n        }\n        return txt;\n      }\n      function stepThroughMatches(node, matches, replaceFn) {\n        var startNode, endNode, startNodeIndex, endNodeIndex, innerNodes = [], atIndex = 0, curNode = node, matchLocation, matchIndex = 0;\n        matches = matches.slice(0);\n        matches.sort(function (a, b) {\n          return a.start - b.start;\n        });\n        matchLocation = matches.shift();\n        out:\n          while (true) {\n            if (blockElementsMap[curNode.nodeName] || shortEndedElementsMap[curNode.nodeName] || isContentEditableFalse(curNode)) {\n              atIndex++;\n            }\n            if (curNode.nodeType === 3) {\n              if (!endNode && curNode.length + atIndex >= matchLocation.end) {\n                endNode = curNode;\n                endNodeIndex = matchLocation.end - atIndex;\n              } else if (startNode) {\n                innerNodes.push(curNode);\n              }\n              if (!startNode && curNode.length + atIndex > matchLocation.start) {\n                startNode = curNode;\n                startNodeIndex = matchLocation.start - atIndex;\n              }\n              atIndex += curNode.length;\n            }\n            if (startNode && endNode) {\n              curNode = replaceFn({\n                startNode: startNode,\n                startNodeIndex: startNodeIndex,\n                endNode: endNode,\n                endNodeIndex: endNodeIndex,\n                innerNodes: innerNodes,\n                match: matchLocation.text,\n                matchIndex: matchIndex\n              });\n              atIndex -= endNode.length - endNodeIndex;\n              startNode = null;\n              endNode = null;\n              innerNodes = [];\n              matchLocation = matches.shift();\n              matchIndex++;\n              if (!matchLocation) {\n                break;\n              }\n            } else if ((!hiddenTextElementsMap[curNode.nodeName] || blockElementsMap[curNode.nodeName]) && curNode.firstChild) {\n              if (!isContentEditableFalse(curNode)) {\n                curNode = curNode.firstChild;\n                continue;\n              }\n            } else if (curNode.nextSibling) {\n              curNode = curNode.nextSibling;\n              continue;\n            }\n            while (true) {\n              if (curNode.nextSibling) {\n                curNode = curNode.nextSibling;\n                break;\n              } else if (curNode.parentNode !== node) {\n                curNode = curNode.parentNode;\n              } else {\n                break out;\n              }\n            }\n          }\n      }\n      function genReplacer(callback) {\n        function makeReplacementNode(fill, matchIndex) {\n          var match = matches[matchIndex];\n          if (!match.stencil) {\n            match.stencil = callback(match);\n          }\n          var clone = match.stencil.cloneNode(false);\n          clone.setAttribute('data-mce-index', matchIndex);\n          if (fill) {\n            clone.appendChild(dom.doc.createTextNode(fill));\n          }\n          return clone;\n        }\n        return function (range) {\n          var before;\n          var after;\n          var parentNode;\n          var startNode = range.startNode;\n          var endNode = range.endNode;\n          var matchIndex = range.matchIndex;\n          var doc = dom.doc;\n          if (startNode === endNode) {\n            var node_1 = startNode;\n            parentNode = node_1.parentNode;\n            if (range.startNodeIndex > 0) {\n              before = doc.createTextNode(node_1.data.substring(0, range.startNodeIndex));\n              parentNode.insertBefore(before, node_1);\n            }\n            var el = makeReplacementNode(range.match, matchIndex);\n            parentNode.insertBefore(el, node_1);\n            if (range.endNodeIndex < node_1.length) {\n              after = doc.createTextNode(node_1.data.substring(range.endNodeIndex));\n              parentNode.insertBefore(after, node_1);\n            }\n            node_1.parentNode.removeChild(node_1);\n            return el;\n          }\n          before = doc.createTextNode(startNode.data.substring(0, range.startNodeIndex));\n          after = doc.createTextNode(endNode.data.substring(range.endNodeIndex));\n          var elA = makeReplacementNode(startNode.data.substring(range.startNodeIndex), matchIndex);\n          for (var i = 0, l = range.innerNodes.length; i < l; ++i) {\n            var innerNode = range.innerNodes[i];\n            var innerEl = makeReplacementNode(innerNode.data, matchIndex);\n            innerNode.parentNode.replaceChild(innerEl, innerNode);\n          }\n          var elB = makeReplacementNode(endNode.data.substring(0, range.endNodeIndex), matchIndex);\n          parentNode = startNode.parentNode;\n          parentNode.insertBefore(before, startNode);\n          parentNode.insertBefore(elA, startNode);\n          parentNode.removeChild(startNode);\n          parentNode = endNode.parentNode;\n          parentNode.insertBefore(elB, endNode);\n          parentNode.insertBefore(after, endNode);\n          parentNode.removeChild(endNode);\n          return elB;\n        };\n      }\n      function unwrapElement(element) {\n        var parentNode = element.parentNode;\n        parentNode.insertBefore(element.firstChild, element);\n        element.parentNode.removeChild(element);\n      }\n      function hasClass(elm) {\n        return elm.className.indexOf('mce-spellchecker-word') !== -1;\n      }\n      function getWrappersByIndex(index) {\n        var elements = node.getElementsByTagName('*'), wrappers = [];\n        index = typeof index === 'number' ? '' + index : null;\n        for (var i = 0; i < elements.length; i++) {\n          var element = elements[i], dataIndex = element.getAttribute('data-mce-index');\n          if (dataIndex !== null && dataIndex.length && hasClass(element)) {\n            if (dataIndex === index || index === null) {\n              wrappers.push(element);\n            }\n          }\n        }\n        return wrappers;\n      }\n      function indexOf(match) {\n        var i = matches.length;\n        while (i--) {\n          if (matches[i] === match) {\n            return i;\n          }\n        }\n        return -1;\n      }\n      function filter(callback) {\n        var filteredMatches = [];\n        each(function (match, i) {\n          if (callback(match, i)) {\n            filteredMatches.push(match);\n          }\n        });\n        matches = filteredMatches;\n        return this;\n      }\n      function each(callback) {\n        for (var i = 0, l = matches.length; i < l; i++) {\n          if (callback(matches[i], i) === false) {\n            break;\n          }\n        }\n        return this;\n      }\n      function wrap(callback) {\n        if (matches.length) {\n          stepThroughMatches(node, matches, genReplacer(callback));\n        }\n        return this;\n      }\n      function find(regex, data) {\n        if (text && regex.global) {\n          while (m = regex.exec(text)) {\n            matches.push(createMatch(m, data));\n          }\n        }\n        return this;\n      }\n      function unwrap(match) {\n        var i;\n        var elements = getWrappersByIndex(match ? indexOf(match) : null);\n        i = elements.length;\n        while (i--) {\n          unwrapElement(elements[i]);\n        }\n        return this;\n      }\n      function matchFromElement(element) {\n        return matches[element.getAttribute('data-mce-index')];\n      }\n      function elementFromMatch(match) {\n        return getWrappersByIndex(indexOf(match))[0];\n      }\n      function add(start, length, data) {\n        matches.push({\n          start: start,\n          end: start + length,\n          text: text.substr(start, length),\n          data: data\n        });\n        return this;\n      }\n      function rangeFromMatch(match) {\n        var wrappers = getWrappersByIndex(indexOf(match));\n        var rng = editor.dom.createRng();\n        rng.setStartBefore(wrappers[0]);\n        rng.setEndAfter(wrappers[wrappers.length - 1]);\n        return rng;\n      }\n      function replace(match, text) {\n        var rng = rangeFromMatch(match);\n        rng.deleteContents();\n        if (text.length > 0) {\n          rng.insertNode(editor.dom.doc.createTextNode(text));\n        }\n        return rng;\n      }\n      function reset() {\n        matches.splice(0, matches.length);\n        unwrap();\n        return this;\n      }\n      text = getText(node);\n      return {\n        text: text,\n        matches: matches,\n        each: each,\n        filter: filter,\n        reset: reset,\n        matchFromElement: matchFromElement,\n        elementFromMatch: elementFromMatch,\n        find: find,\n        add: add,\n        wrap: wrap,\n        unwrap: unwrap,\n        replace: replace,\n        rangeFromMatch: rangeFromMatch,\n        indexOf: indexOf\n      };\n    };\n\n    var getTextMatcher = function (editor, textMatcherState) {\n      if (!textMatcherState.get()) {\n        var textMatcher = DomTextMatcher(editor.getBody(), editor);\n        textMatcherState.set(textMatcher);\n      }\n      return textMatcherState.get();\n    };\n    var isEmpty = function (obj) {\n      for (var _ in obj) {\n        return false;\n      }\n      return true;\n    };\n    var defaultSpellcheckCallback = function (editor, pluginUrl, currentLanguageState) {\n      return function (method, text, doneCallback, errorCallback) {\n        var data = {\n          method: method,\n          lang: currentLanguageState.get()\n        };\n        var postData = '';\n        data[method === 'addToDictionary' ? 'word' : 'text'] = text;\n        global$1.each(data, function (value, key) {\n          if (postData) {\n            postData += '&';\n          }\n          postData += key + '=' + encodeURIComponent(value);\n        });\n        global$3.send({\n          url: new global$2(pluginUrl).toAbsolute(Settings.getRpcUrl(editor)),\n          type: 'post',\n          content_type: 'application/x-www-form-urlencoded',\n          data: postData,\n          success: function (result) {\n            result = JSON.parse(result);\n            if (!result) {\n              var message = editor.translate('Server response wasn\\'t proper JSON.');\n              errorCallback(message);\n            } else if (result.error) {\n              errorCallback(result.error);\n            } else {\n              doneCallback(result);\n            }\n          },\n          error: function () {\n            var message = editor.translate('The spelling service was not found: (') + Settings.getRpcUrl(editor) + editor.translate(')');\n            errorCallback(message);\n          }\n        });\n      };\n    };\n    var sendRpcCall = function (editor, pluginUrl, currentLanguageState, name, data, successCallback, errorCallback) {\n      var userSpellcheckCallback = Settings.getSpellcheckerCallback(editor);\n      var spellCheckCallback = userSpellcheckCallback ? userSpellcheckCallback : defaultSpellcheckCallback(editor, pluginUrl, currentLanguageState);\n      spellCheckCallback.call(editor.plugins.spellchecker, name, data, successCallback, errorCallback);\n    };\n    var spellcheck = function (editor, pluginUrl, startedState, textMatcherState, lastSuggestionsState, currentLanguageState) {\n      if (finish(editor, startedState, textMatcherState)) {\n        return;\n      }\n      var errorCallback = function (message) {\n        editor.notificationManager.open({\n          text: message,\n          type: 'error'\n        });\n        editor.setProgressState(false);\n        finish(editor, startedState, textMatcherState);\n      };\n      var successCallback = function (data) {\n        markErrors(editor, startedState, textMatcherState, lastSuggestionsState, data);\n      };\n      editor.setProgressState(true);\n      sendRpcCall(editor, pluginUrl, currentLanguageState, 'spellcheck', getTextMatcher(editor, textMatcherState).text, successCallback, errorCallback);\n      editor.focus();\n    };\n    var checkIfFinished = function (editor, startedState, textMatcherState) {\n      if (!editor.dom.select('span.mce-spellchecker-word').length) {\n        finish(editor, startedState, textMatcherState);\n      }\n    };\n    var addToDictionary = function (editor, pluginUrl, startedState, textMatcherState, currentLanguageState, word, spans) {\n      editor.setProgressState(true);\n      sendRpcCall(editor, pluginUrl, currentLanguageState, 'addToDictionary', word, function () {\n        editor.setProgressState(false);\n        editor.dom.remove(spans, true);\n        checkIfFinished(editor, startedState, textMatcherState);\n      }, function (message) {\n        editor.notificationManager.open({\n          text: message,\n          type: 'error'\n        });\n        editor.setProgressState(false);\n      });\n    };\n    var ignoreWord = function (editor, startedState, textMatcherState, word, spans, all) {\n      editor.selection.collapse();\n      if (all) {\n        global$1.each(editor.dom.select('span.mce-spellchecker-word'), function (span) {\n          if (span.getAttribute('data-mce-word') === word) {\n            editor.dom.remove(span, true);\n          }\n        });\n      } else {\n        editor.dom.remove(spans, true);\n      }\n      checkIfFinished(editor, startedState, textMatcherState);\n    };\n    var finish = function (editor, startedState, textMatcherState) {\n      var bookmark = editor.selection.getBookmark();\n      getTextMatcher(editor, textMatcherState).reset();\n      editor.selection.moveToBookmark(bookmark);\n      textMatcherState.set(null);\n      if (startedState.get()) {\n        startedState.set(false);\n        Events.fireSpellcheckEnd(editor);\n        return true;\n      }\n    };\n    var getElmIndex = function (elm) {\n      var value = elm.getAttribute('data-mce-index');\n      if (typeof value === 'number') {\n        return '' + value;\n      }\n      return value;\n    };\n    var findSpansByIndex = function (editor, index) {\n      var nodes;\n      var spans = [];\n      nodes = global$1.toArray(editor.getBody().getElementsByTagName('span'));\n      if (nodes.length) {\n        for (var i = 0; i < nodes.length; i++) {\n          var nodeIndex = getElmIndex(nodes[i]);\n          if (nodeIndex === null || !nodeIndex.length) {\n            continue;\n          }\n          if (nodeIndex === index.toString()) {\n            spans.push(nodes[i]);\n          }\n        }\n      }\n      return spans;\n    };\n    var markErrors = function (editor, startedState, textMatcherState, lastSuggestionsState, data) {\n      var suggestions, hasDictionarySupport;\n      if (typeof data !== 'string' && data.words) {\n        hasDictionarySupport = !!data.dictionary;\n        suggestions = data.words;\n      } else {\n        suggestions = data;\n      }\n      editor.setProgressState(false);\n      if (isEmpty(suggestions)) {\n        var message = editor.translate('No misspellings found.');\n        editor.notificationManager.open({\n          text: message,\n          type: 'info'\n        });\n        startedState.set(false);\n        return;\n      }\n      lastSuggestionsState.set({\n        suggestions: suggestions,\n        hasDictionarySupport: hasDictionarySupport\n      });\n      var bookmark = editor.selection.getBookmark();\n      getTextMatcher(editor, textMatcherState).find(Settings.getSpellcheckerWordcharPattern(editor)).filter(function (match) {\n        return !!suggestions[match.text];\n      }).wrap(function (match) {\n        return editor.dom.create('span', {\n          'class': 'mce-spellchecker-word',\n          'data-mce-bogus': 1,\n          'data-mce-word': match.text\n        });\n      });\n      editor.selection.moveToBookmark(bookmark);\n      startedState.set(true);\n      Events.fireSpellcheckStart(editor);\n    };\n    var Actions = {\n      spellcheck: spellcheck,\n      checkIfFinished: checkIfFinished,\n      addToDictionary: addToDictionary,\n      ignoreWord: ignoreWord,\n      findSpansByIndex: findSpansByIndex,\n      getElmIndex: getElmIndex,\n      markErrors: markErrors\n    };\n\n    var get = function (editor, startedState, lastSuggestionsState, textMatcherState, currentLanguageState, url) {\n      var getLanguage = function () {\n        return currentLanguageState.get();\n      };\n      var getWordCharPattern = function () {\n        return Settings.getSpellcheckerWordcharPattern(editor);\n      };\n      var markErrors = function (data) {\n        Actions.markErrors(editor, startedState, textMatcherState, lastSuggestionsState, data);\n      };\n      var getTextMatcher = function () {\n        return textMatcherState.get();\n      };\n      return {\n        getTextMatcher: getTextMatcher,\n        getWordCharPattern: getWordCharPattern,\n        markErrors: markErrors,\n        getLanguage: getLanguage\n      };\n    };\n    var Api = { get: get };\n\n    var register = function (editor, pluginUrl, startedState, textMatcherState, lastSuggestionsState, currentLanguageState) {\n      editor.addCommand('mceSpellCheck', function () {\n        Actions.spellcheck(editor, pluginUrl, startedState, textMatcherState, lastSuggestionsState, currentLanguageState);\n      });\n    };\n    var Commands = { register: register };\n\n    var buildMenuItems = function (listName, languageValues) {\n      var items = [];\n      global$1.each(languageValues, function (languageValue) {\n        items.push({\n          selectable: true,\n          text: languageValue.name,\n          data: languageValue.value\n        });\n      });\n      return items;\n    };\n    var updateSelection = function (editor, currentLanguageState) {\n      return function (e) {\n        var selectedLanguage = currentLanguageState.get();\n        e.control.items().each(function (ctrl) {\n          ctrl.active(ctrl.settings.data === selectedLanguage);\n        });\n      };\n    };\n    var getItems = function (editor) {\n      return global$1.map(Settings.getLanguages(editor).split(','), function (langPair) {\n        langPair = langPair.split('=');\n        return {\n          name: langPair[0],\n          value: langPair[1]\n        };\n      });\n    };\n    var register$1 = function (editor, pluginUrl, startedState, textMatcherState, currentLanguageState, lastSuggestionsState) {\n      var languageMenuItems = buildMenuItems('Language', getItems(editor));\n      var startSpellchecking = function () {\n        Actions.spellcheck(editor, pluginUrl, startedState, textMatcherState, lastSuggestionsState, currentLanguageState);\n      };\n      var buttonArgs = {\n        tooltip: 'Spellcheck',\n        onclick: startSpellchecking,\n        onPostRender: function (e) {\n          var ctrl = e.control;\n          editor.on('SpellcheckStart SpellcheckEnd', function () {\n            ctrl.active(startedState.get());\n          });\n        }\n      };\n      if (languageMenuItems.length > 1) {\n        buttonArgs.type = 'splitbutton';\n        buttonArgs.menu = languageMenuItems;\n        buttonArgs.onshow = updateSelection(editor, currentLanguageState);\n        buttonArgs.onselect = function (e) {\n          currentLanguageState.set(e.control.settings.data);\n        };\n      }\n      editor.addButton('spellchecker', buttonArgs);\n      editor.addMenuItem('spellchecker', {\n        text: 'Spellcheck',\n        context: 'tools',\n        onclick: startSpellchecking,\n        selectable: true,\n        onPostRender: function () {\n          var self = this;\n          self.active(startedState.get());\n          editor.on('SpellcheckStart SpellcheckEnd', function () {\n            self.active(startedState.get());\n          });\n        }\n      });\n    };\n    var Buttons = { register: register$1 };\n\n    var global$4 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\n\n    var global$5 = tinymce.util.Tools.resolve('tinymce.ui.Factory');\n\n    var suggestionsMenu;\n    var showSuggestions = function (editor, pluginUrl, lastSuggestionsState, startedState, textMatcherState, currentLanguageState, word, spans) {\n      var items = [], suggestions = lastSuggestionsState.get().suggestions[word];\n      global$1.each(suggestions, function (suggestion) {\n        items.push({\n          text: suggestion,\n          onclick: function () {\n            editor.insertContent(editor.dom.encode(suggestion));\n            editor.dom.remove(spans);\n            Actions.checkIfFinished(editor, startedState, textMatcherState);\n          }\n        });\n      });\n      items.push({ text: '-' });\n      var hasDictionarySupport = lastSuggestionsState.get().hasDictionarySupport;\n      if (hasDictionarySupport) {\n        items.push({\n          text: 'Add to Dictionary',\n          onclick: function () {\n            Actions.addToDictionary(editor, pluginUrl, startedState, textMatcherState, currentLanguageState, word, spans);\n          }\n        });\n      }\n      items.push.apply(items, [\n        {\n          text: 'Ignore',\n          onclick: function () {\n            Actions.ignoreWord(editor, startedState, textMatcherState, word, spans);\n          }\n        },\n        {\n          text: 'Ignore all',\n          onclick: function () {\n            Actions.ignoreWord(editor, startedState, textMatcherState, word, spans, true);\n          }\n        }\n      ]);\n      suggestionsMenu = global$5.create('menu', {\n        items: items,\n        context: 'contextmenu',\n        onautohide: function (e) {\n          if (e.target.className.indexOf('spellchecker') !== -1) {\n            e.preventDefault();\n          }\n        },\n        onhide: function () {\n          suggestionsMenu.remove();\n          suggestionsMenu = null;\n        }\n      });\n      suggestionsMenu.renderTo(domGlobals.document.body);\n      var pos = global$4.DOM.getPos(editor.getContentAreaContainer());\n      var targetPos = editor.dom.getPos(spans[0]);\n      var root = editor.dom.getRoot();\n      if (root.nodeName === 'BODY') {\n        targetPos.x -= root.ownerDocument.documentElement.scrollLeft || root.scrollLeft;\n        targetPos.y -= root.ownerDocument.documentElement.scrollTop || root.scrollTop;\n      } else {\n        targetPos.x -= root.scrollLeft;\n        targetPos.y -= root.scrollTop;\n      }\n      pos.x += targetPos.x;\n      pos.y += targetPos.y;\n      suggestionsMenu.moveTo(pos.x, pos.y + spans[0].offsetHeight);\n    };\n    var setup = function (editor, pluginUrl, lastSuggestionsState, startedState, textMatcherState, currentLanguageState) {\n      editor.on('click', function (e) {\n        var target = e.target;\n        if (target.className === 'mce-spellchecker-word') {\n          e.preventDefault();\n          var spans = Actions.findSpansByIndex(editor, Actions.getElmIndex(target));\n          if (spans.length > 0) {\n            var rng = editor.dom.createRng();\n            rng.setStartBefore(spans[0]);\n            rng.setEndAfter(spans[spans.length - 1]);\n            editor.selection.setRng(rng);\n            showSuggestions(editor, pluginUrl, lastSuggestionsState, startedState, textMatcherState, currentLanguageState, target.getAttribute('data-mce-word'), spans);\n          }\n        }\n      });\n    };\n    var SuggestionsMenu = { setup: setup };\n\n    global.add('spellchecker', function (editor, pluginUrl) {\n      if (DetectProPlugin.hasProPlugin(editor) === false) {\n        var startedState = Cell(false);\n        var currentLanguageState = Cell(Settings.getLanguage(editor));\n        var textMatcherState = Cell(null);\n        var lastSuggestionsState = Cell(null);\n        Buttons.register(editor, pluginUrl, startedState, textMatcherState, currentLanguageState, lastSuggestionsState);\n        SuggestionsMenu.setup(editor, pluginUrl, lastSuggestionsState, startedState, textMatcherState, currentLanguageState);\n        Commands.register(editor, pluginUrl, startedState, textMatcherState, lastSuggestionsState, currentLanguageState);\n        return Api.get(editor, startedState, lastSuggestionsState, textMatcherState, currentLanguageState, pluginUrl);\n      }\n    });\n    function Plugin () {\n    }\n\n    return Plugin;\n\n}(window));\n})();\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/10.90dc81b14450100c0a92.js","// Exports the \"spellchecker\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/spellchecker')\n//   ES2015:\n//     import 'tinymce/plugins/spellchecker'\nrequire('./plugin.js');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tinymce/plugins/spellchecker/index.js\n// module id = BT+F\n// module chunks = 10","(function () {\nvar spellchecker = (function (domGlobals) {\n    'use strict';\n\n    var Cell = function (initial) {\n      var value = initial;\n      var get = function () {\n        return value;\n      };\n      var set = function (v) {\n        value = v;\n      };\n      var clone = function () {\n        return Cell(get());\n      };\n      return {\n        get: get,\n        set: set,\n        clone: clone\n      };\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    var hasProPlugin = function (editor) {\n      if (/(^|[ ,])tinymcespellchecker([, ]|$)/.test(editor.settings.plugins) && global.get('tinymcespellchecker')) {\n        if (typeof domGlobals.window.console !== 'undefined' && domGlobals.window.console.log) {\n          domGlobals.window.console.log('Spell Checker Pro is incompatible with Spell Checker plugin! ' + 'Remove \\'spellchecker\\' from the \\'plugins\\' option.');\n        }\n        return true;\n      } else {\n        return false;\n      }\n    };\n    var DetectProPlugin = { hasProPlugin: hasProPlugin };\n\n    var getLanguages = function (editor) {\n      var defaultLanguages = 'English=en,Danish=da,Dutch=nl,Finnish=fi,French=fr_FR,German=de,Italian=it,Polish=pl,Portuguese=pt_BR,Spanish=es,Swedish=sv';\n      return editor.getParam('spellchecker_languages', defaultLanguages);\n    };\n    var getLanguage = function (editor) {\n      var defaultLanguage = editor.getParam('language', 'en');\n      return editor.getParam('spellchecker_language', defaultLanguage);\n    };\n    var getRpcUrl = function (editor) {\n      return editor.getParam('spellchecker_rpc_url');\n    };\n    var getSpellcheckerCallback = function (editor) {\n      return editor.getParam('spellchecker_callback');\n    };\n    var getSpellcheckerWordcharPattern = function (editor) {\n      var defaultPattern = new RegExp('[^' + '\\\\s!\"#$%&()*+,-./:;<=>?@[\\\\]^_{|}`' + '\\xA7\\xA9\\xAB\\xAE\\xB1\\xB6\\xB7\\xB8\\xBB' + '\\xBC\\xBD\\xBE\\xBF\\xD7\\xF7\\xA4\\u201D\\u201C\\u201E\\xA0\\u2002\\u2003\\u2009' + ']+', 'g');\n      return editor.getParam('spellchecker_wordchar_pattern', defaultPattern);\n    };\n    var Settings = {\n      getLanguages: getLanguages,\n      getLanguage: getLanguage,\n      getRpcUrl: getRpcUrl,\n      getSpellcheckerCallback: getSpellcheckerCallback,\n      getSpellcheckerWordcharPattern: getSpellcheckerWordcharPattern\n    };\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.util.URI');\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.util.XHR');\n\n    var fireSpellcheckStart = function (editor) {\n      return editor.fire('SpellcheckStart');\n    };\n    var fireSpellcheckEnd = function (editor) {\n      return editor.fire('SpellcheckEnd');\n    };\n    var Events = {\n      fireSpellcheckStart: fireSpellcheckStart,\n      fireSpellcheckEnd: fireSpellcheckEnd\n    };\n\n    function isContentEditableFalse(node) {\n      return node && node.nodeType === 1 && node.contentEditable === 'false';\n    }\n    var DomTextMatcher = function (node, editor) {\n      var m, matches = [], text;\n      var dom = editor.dom;\n      var blockElementsMap, hiddenTextElementsMap, shortEndedElementsMap;\n      blockElementsMap = editor.schema.getBlockElements();\n      hiddenTextElementsMap = editor.schema.getWhiteSpaceElements();\n      shortEndedElementsMap = editor.schema.getShortEndedElements();\n      function createMatch(m, data) {\n        if (!m[0]) {\n          throw new Error('findAndReplaceDOMText cannot handle zero-length matches');\n        }\n        return {\n          start: m.index,\n          end: m.index + m[0].length,\n          text: m[0],\n          data: data\n        };\n      }\n      function getText(node) {\n        var txt;\n        if (node.nodeType === 3) {\n          return node.data;\n        }\n        if (hiddenTextElementsMap[node.nodeName] && !blockElementsMap[node.nodeName]) {\n          return '';\n        }\n        if (isContentEditableFalse(node)) {\n          return '\\n';\n        }\n        txt = '';\n        if (blockElementsMap[node.nodeName] || shortEndedElementsMap[node.nodeName]) {\n          txt += '\\n';\n        }\n        if (node = node.firstChild) {\n          do {\n            txt += getText(node);\n          } while (node = node.nextSibling);\n        }\n        return txt;\n      }\n      function stepThroughMatches(node, matches, replaceFn) {\n        var startNode, endNode, startNodeIndex, endNodeIndex, innerNodes = [], atIndex = 0, curNode = node, matchLocation, matchIndex = 0;\n        matches = matches.slice(0);\n        matches.sort(function (a, b) {\n          return a.start - b.start;\n        });\n        matchLocation = matches.shift();\n        out:\n          while (true) {\n            if (blockElementsMap[curNode.nodeName] || shortEndedElementsMap[curNode.nodeName] || isContentEditableFalse(curNode)) {\n              atIndex++;\n            }\n            if (curNode.nodeType === 3) {\n              if (!endNode && curNode.length + atIndex >= matchLocation.end) {\n                endNode = curNode;\n                endNodeIndex = matchLocation.end - atIndex;\n              } else if (startNode) {\n                innerNodes.push(curNode);\n              }\n              if (!startNode && curNode.length + atIndex > matchLocation.start) {\n                startNode = curNode;\n                startNodeIndex = matchLocation.start - atIndex;\n              }\n              atIndex += curNode.length;\n            }\n            if (startNode && endNode) {\n              curNode = replaceFn({\n                startNode: startNode,\n                startNodeIndex: startNodeIndex,\n                endNode: endNode,\n                endNodeIndex: endNodeIndex,\n                innerNodes: innerNodes,\n                match: matchLocation.text,\n                matchIndex: matchIndex\n              });\n              atIndex -= endNode.length - endNodeIndex;\n              startNode = null;\n              endNode = null;\n              innerNodes = [];\n              matchLocation = matches.shift();\n              matchIndex++;\n              if (!matchLocation) {\n                break;\n              }\n            } else if ((!hiddenTextElementsMap[curNode.nodeName] || blockElementsMap[curNode.nodeName]) && curNode.firstChild) {\n              if (!isContentEditableFalse(curNode)) {\n                curNode = curNode.firstChild;\n                continue;\n              }\n            } else if (curNode.nextSibling) {\n              curNode = curNode.nextSibling;\n              continue;\n            }\n            while (true) {\n              if (curNode.nextSibling) {\n                curNode = curNode.nextSibling;\n                break;\n              } else if (curNode.parentNode !== node) {\n                curNode = curNode.parentNode;\n              } else {\n                break out;\n              }\n            }\n          }\n      }\n      function genReplacer(callback) {\n        function makeReplacementNode(fill, matchIndex) {\n          var match = matches[matchIndex];\n          if (!match.stencil) {\n            match.stencil = callback(match);\n          }\n          var clone = match.stencil.cloneNode(false);\n          clone.setAttribute('data-mce-index', matchIndex);\n          if (fill) {\n            clone.appendChild(dom.doc.createTextNode(fill));\n          }\n          return clone;\n        }\n        return function (range) {\n          var before;\n          var after;\n          var parentNode;\n          var startNode = range.startNode;\n          var endNode = range.endNode;\n          var matchIndex = range.matchIndex;\n          var doc = dom.doc;\n          if (startNode === endNode) {\n            var node_1 = startNode;\n            parentNode = node_1.parentNode;\n            if (range.startNodeIndex > 0) {\n              before = doc.createTextNode(node_1.data.substring(0, range.startNodeIndex));\n              parentNode.insertBefore(before, node_1);\n            }\n            var el = makeReplacementNode(range.match, matchIndex);\n            parentNode.insertBefore(el, node_1);\n            if (range.endNodeIndex < node_1.length) {\n              after = doc.createTextNode(node_1.data.substring(range.endNodeIndex));\n              parentNode.insertBefore(after, node_1);\n            }\n            node_1.parentNode.removeChild(node_1);\n            return el;\n          }\n          before = doc.createTextNode(startNode.data.substring(0, range.startNodeIndex));\n          after = doc.createTextNode(endNode.data.substring(range.endNodeIndex));\n          var elA = makeReplacementNode(startNode.data.substring(range.startNodeIndex), matchIndex);\n          for (var i = 0, l = range.innerNodes.length; i < l; ++i) {\n            var innerNode = range.innerNodes[i];\n            var innerEl = makeReplacementNode(innerNode.data, matchIndex);\n            innerNode.parentNode.replaceChild(innerEl, innerNode);\n          }\n          var elB = makeReplacementNode(endNode.data.substring(0, range.endNodeIndex), matchIndex);\n          parentNode = startNode.parentNode;\n          parentNode.insertBefore(before, startNode);\n          parentNode.insertBefore(elA, startNode);\n          parentNode.removeChild(startNode);\n          parentNode = endNode.parentNode;\n          parentNode.insertBefore(elB, endNode);\n          parentNode.insertBefore(after, endNode);\n          parentNode.removeChild(endNode);\n          return elB;\n        };\n      }\n      function unwrapElement(element) {\n        var parentNode = element.parentNode;\n        parentNode.insertBefore(element.firstChild, element);\n        element.parentNode.removeChild(element);\n      }\n      function hasClass(elm) {\n        return elm.className.indexOf('mce-spellchecker-word') !== -1;\n      }\n      function getWrappersByIndex(index) {\n        var elements = node.getElementsByTagName('*'), wrappers = [];\n        index = typeof index === 'number' ? '' + index : null;\n        for (var i = 0; i < elements.length; i++) {\n          var element = elements[i], dataIndex = element.getAttribute('data-mce-index');\n          if (dataIndex !== null && dataIndex.length && hasClass(element)) {\n            if (dataIndex === index || index === null) {\n              wrappers.push(element);\n            }\n          }\n        }\n        return wrappers;\n      }\n      function indexOf(match) {\n        var i = matches.length;\n        while (i--) {\n          if (matches[i] === match) {\n            return i;\n          }\n        }\n        return -1;\n      }\n      function filter(callback) {\n        var filteredMatches = [];\n        each(function (match, i) {\n          if (callback(match, i)) {\n            filteredMatches.push(match);\n          }\n        });\n        matches = filteredMatches;\n        return this;\n      }\n      function each(callback) {\n        for (var i = 0, l = matches.length; i < l; i++) {\n          if (callback(matches[i], i) === false) {\n            break;\n          }\n        }\n        return this;\n      }\n      function wrap(callback) {\n        if (matches.length) {\n          stepThroughMatches(node, matches, genReplacer(callback));\n        }\n        return this;\n      }\n      function find(regex, data) {\n        if (text && regex.global) {\n          while (m = regex.exec(text)) {\n            matches.push(createMatch(m, data));\n          }\n        }\n        return this;\n      }\n      function unwrap(match) {\n        var i;\n        var elements = getWrappersByIndex(match ? indexOf(match) : null);\n        i = elements.length;\n        while (i--) {\n          unwrapElement(elements[i]);\n        }\n        return this;\n      }\n      function matchFromElement(element) {\n        return matches[element.getAttribute('data-mce-index')];\n      }\n      function elementFromMatch(match) {\n        return getWrappersByIndex(indexOf(match))[0];\n      }\n      function add(start, length, data) {\n        matches.push({\n          start: start,\n          end: start + length,\n          text: text.substr(start, length),\n          data: data\n        });\n        return this;\n      }\n      function rangeFromMatch(match) {\n        var wrappers = getWrappersByIndex(indexOf(match));\n        var rng = editor.dom.createRng();\n        rng.setStartBefore(wrappers[0]);\n        rng.setEndAfter(wrappers[wrappers.length - 1]);\n        return rng;\n      }\n      function replace(match, text) {\n        var rng = rangeFromMatch(match);\n        rng.deleteContents();\n        if (text.length > 0) {\n          rng.insertNode(editor.dom.doc.createTextNode(text));\n        }\n        return rng;\n      }\n      function reset() {\n        matches.splice(0, matches.length);\n        unwrap();\n        return this;\n      }\n      text = getText(node);\n      return {\n        text: text,\n        matches: matches,\n        each: each,\n        filter: filter,\n        reset: reset,\n        matchFromElement: matchFromElement,\n        elementFromMatch: elementFromMatch,\n        find: find,\n        add: add,\n        wrap: wrap,\n        unwrap: unwrap,\n        replace: replace,\n        rangeFromMatch: rangeFromMatch,\n        indexOf: indexOf\n      };\n    };\n\n    var getTextMatcher = function (editor, textMatcherState) {\n      if (!textMatcherState.get()) {\n        var textMatcher = DomTextMatcher(editor.getBody(), editor);\n        textMatcherState.set(textMatcher);\n      }\n      return textMatcherState.get();\n    };\n    var isEmpty = function (obj) {\n      for (var _ in obj) {\n        return false;\n      }\n      return true;\n    };\n    var defaultSpellcheckCallback = function (editor, pluginUrl, currentLanguageState) {\n      return function (method, text, doneCallback, errorCallback) {\n        var data = {\n          method: method,\n          lang: currentLanguageState.get()\n        };\n        var postData = '';\n        data[method === 'addToDictionary' ? 'word' : 'text'] = text;\n        global$1.each(data, function (value, key) {\n          if (postData) {\n            postData += '&';\n          }\n          postData += key + '=' + encodeURIComponent(value);\n        });\n        global$3.send({\n          url: new global$2(pluginUrl).toAbsolute(Settings.getRpcUrl(editor)),\n          type: 'post',\n          content_type: 'application/x-www-form-urlencoded',\n          data: postData,\n          success: function (result) {\n            result = JSON.parse(result);\n            if (!result) {\n              var message = editor.translate('Server response wasn\\'t proper JSON.');\n              errorCallback(message);\n            } else if (result.error) {\n              errorCallback(result.error);\n            } else {\n              doneCallback(result);\n            }\n          },\n          error: function () {\n            var message = editor.translate('The spelling service was not found: (') + Settings.getRpcUrl(editor) + editor.translate(')');\n            errorCallback(message);\n          }\n        });\n      };\n    };\n    var sendRpcCall = function (editor, pluginUrl, currentLanguageState, name, data, successCallback, errorCallback) {\n      var userSpellcheckCallback = Settings.getSpellcheckerCallback(editor);\n      var spellCheckCallback = userSpellcheckCallback ? userSpellcheckCallback : defaultSpellcheckCallback(editor, pluginUrl, currentLanguageState);\n      spellCheckCallback.call(editor.plugins.spellchecker, name, data, successCallback, errorCallback);\n    };\n    var spellcheck = function (editor, pluginUrl, startedState, textMatcherState, lastSuggestionsState, currentLanguageState) {\n      if (finish(editor, startedState, textMatcherState)) {\n        return;\n      }\n      var errorCallback = function (message) {\n        editor.notificationManager.open({\n          text: message,\n          type: 'error'\n        });\n        editor.setProgressState(false);\n        finish(editor, startedState, textMatcherState);\n      };\n      var successCallback = function (data) {\n        markErrors(editor, startedState, textMatcherState, lastSuggestionsState, data);\n      };\n      editor.setProgressState(true);\n      sendRpcCall(editor, pluginUrl, currentLanguageState, 'spellcheck', getTextMatcher(editor, textMatcherState).text, successCallback, errorCallback);\n      editor.focus();\n    };\n    var checkIfFinished = function (editor, startedState, textMatcherState) {\n      if (!editor.dom.select('span.mce-spellchecker-word').length) {\n        finish(editor, startedState, textMatcherState);\n      }\n    };\n    var addToDictionary = function (editor, pluginUrl, startedState, textMatcherState, currentLanguageState, word, spans) {\n      editor.setProgressState(true);\n      sendRpcCall(editor, pluginUrl, currentLanguageState, 'addToDictionary', word, function () {\n        editor.setProgressState(false);\n        editor.dom.remove(spans, true);\n        checkIfFinished(editor, startedState, textMatcherState);\n      }, function (message) {\n        editor.notificationManager.open({\n          text: message,\n          type: 'error'\n        });\n        editor.setProgressState(false);\n      });\n    };\n    var ignoreWord = function (editor, startedState, textMatcherState, word, spans, all) {\n      editor.selection.collapse();\n      if (all) {\n        global$1.each(editor.dom.select('span.mce-spellchecker-word'), function (span) {\n          if (span.getAttribute('data-mce-word') === word) {\n            editor.dom.remove(span, true);\n          }\n        });\n      } else {\n        editor.dom.remove(spans, true);\n      }\n      checkIfFinished(editor, startedState, textMatcherState);\n    };\n    var finish = function (editor, startedState, textMatcherState) {\n      var bookmark = editor.selection.getBookmark();\n      getTextMatcher(editor, textMatcherState).reset();\n      editor.selection.moveToBookmark(bookmark);\n      textMatcherState.set(null);\n      if (startedState.get()) {\n        startedState.set(false);\n        Events.fireSpellcheckEnd(editor);\n        return true;\n      }\n    };\n    var getElmIndex = function (elm) {\n      var value = elm.getAttribute('data-mce-index');\n      if (typeof value === 'number') {\n        return '' + value;\n      }\n      return value;\n    };\n    var findSpansByIndex = function (editor, index) {\n      var nodes;\n      var spans = [];\n      nodes = global$1.toArray(editor.getBody().getElementsByTagName('span'));\n      if (nodes.length) {\n        for (var i = 0; i < nodes.length; i++) {\n          var nodeIndex = getElmIndex(nodes[i]);\n          if (nodeIndex === null || !nodeIndex.length) {\n            continue;\n          }\n          if (nodeIndex === index.toString()) {\n            spans.push(nodes[i]);\n          }\n        }\n      }\n      return spans;\n    };\n    var markErrors = function (editor, startedState, textMatcherState, lastSuggestionsState, data) {\n      var suggestions, hasDictionarySupport;\n      if (typeof data !== 'string' && data.words) {\n        hasDictionarySupport = !!data.dictionary;\n        suggestions = data.words;\n      } else {\n        suggestions = data;\n      }\n      editor.setProgressState(false);\n      if (isEmpty(suggestions)) {\n        var message = editor.translate('No misspellings found.');\n        editor.notificationManager.open({\n          text: message,\n          type: 'info'\n        });\n        startedState.set(false);\n        return;\n      }\n      lastSuggestionsState.set({\n        suggestions: suggestions,\n        hasDictionarySupport: hasDictionarySupport\n      });\n      var bookmark = editor.selection.getBookmark();\n      getTextMatcher(editor, textMatcherState).find(Settings.getSpellcheckerWordcharPattern(editor)).filter(function (match) {\n        return !!suggestions[match.text];\n      }).wrap(function (match) {\n        return editor.dom.create('span', {\n          'class': 'mce-spellchecker-word',\n          'data-mce-bogus': 1,\n          'data-mce-word': match.text\n        });\n      });\n      editor.selection.moveToBookmark(bookmark);\n      startedState.set(true);\n      Events.fireSpellcheckStart(editor);\n    };\n    var Actions = {\n      spellcheck: spellcheck,\n      checkIfFinished: checkIfFinished,\n      addToDictionary: addToDictionary,\n      ignoreWord: ignoreWord,\n      findSpansByIndex: findSpansByIndex,\n      getElmIndex: getElmIndex,\n      markErrors: markErrors\n    };\n\n    var get = function (editor, startedState, lastSuggestionsState, textMatcherState, currentLanguageState, url) {\n      var getLanguage = function () {\n        return currentLanguageState.get();\n      };\n      var getWordCharPattern = function () {\n        return Settings.getSpellcheckerWordcharPattern(editor);\n      };\n      var markErrors = function (data) {\n        Actions.markErrors(editor, startedState, textMatcherState, lastSuggestionsState, data);\n      };\n      var getTextMatcher = function () {\n        return textMatcherState.get();\n      };\n      return {\n        getTextMatcher: getTextMatcher,\n        getWordCharPattern: getWordCharPattern,\n        markErrors: markErrors,\n        getLanguage: getLanguage\n      };\n    };\n    var Api = { get: get };\n\n    var register = function (editor, pluginUrl, startedState, textMatcherState, lastSuggestionsState, currentLanguageState) {\n      editor.addCommand('mceSpellCheck', function () {\n        Actions.spellcheck(editor, pluginUrl, startedState, textMatcherState, lastSuggestionsState, currentLanguageState);\n      });\n    };\n    var Commands = { register: register };\n\n    var buildMenuItems = function (listName, languageValues) {\n      var items = [];\n      global$1.each(languageValues, function (languageValue) {\n        items.push({\n          selectable: true,\n          text: languageValue.name,\n          data: languageValue.value\n        });\n      });\n      return items;\n    };\n    var updateSelection = function (editor, currentLanguageState) {\n      return function (e) {\n        var selectedLanguage = currentLanguageState.get();\n        e.control.items().each(function (ctrl) {\n          ctrl.active(ctrl.settings.data === selectedLanguage);\n        });\n      };\n    };\n    var getItems = function (editor) {\n      return global$1.map(Settings.getLanguages(editor).split(','), function (langPair) {\n        langPair = langPair.split('=');\n        return {\n          name: langPair[0],\n          value: langPair[1]\n        };\n      });\n    };\n    var register$1 = function (editor, pluginUrl, startedState, textMatcherState, currentLanguageState, lastSuggestionsState) {\n      var languageMenuItems = buildMenuItems('Language', getItems(editor));\n      var startSpellchecking = function () {\n        Actions.spellcheck(editor, pluginUrl, startedState, textMatcherState, lastSuggestionsState, currentLanguageState);\n      };\n      var buttonArgs = {\n        tooltip: 'Spellcheck',\n        onclick: startSpellchecking,\n        onPostRender: function (e) {\n          var ctrl = e.control;\n          editor.on('SpellcheckStart SpellcheckEnd', function () {\n            ctrl.active(startedState.get());\n          });\n        }\n      };\n      if (languageMenuItems.length > 1) {\n        buttonArgs.type = 'splitbutton';\n        buttonArgs.menu = languageMenuItems;\n        buttonArgs.onshow = updateSelection(editor, currentLanguageState);\n        buttonArgs.onselect = function (e) {\n          currentLanguageState.set(e.control.settings.data);\n        };\n      }\n      editor.addButton('spellchecker', buttonArgs);\n      editor.addMenuItem('spellchecker', {\n        text: 'Spellcheck',\n        context: 'tools',\n        onclick: startSpellchecking,\n        selectable: true,\n        onPostRender: function () {\n          var self = this;\n          self.active(startedState.get());\n          editor.on('SpellcheckStart SpellcheckEnd', function () {\n            self.active(startedState.get());\n          });\n        }\n      });\n    };\n    var Buttons = { register: register$1 };\n\n    var global$4 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\n\n    var global$5 = tinymce.util.Tools.resolve('tinymce.ui.Factory');\n\n    var suggestionsMenu;\n    var showSuggestions = function (editor, pluginUrl, lastSuggestionsState, startedState, textMatcherState, currentLanguageState, word, spans) {\n      var items = [], suggestions = lastSuggestionsState.get().suggestions[word];\n      global$1.each(suggestions, function (suggestion) {\n        items.push({\n          text: suggestion,\n          onclick: function () {\n            editor.insertContent(editor.dom.encode(suggestion));\n            editor.dom.remove(spans);\n            Actions.checkIfFinished(editor, startedState, textMatcherState);\n          }\n        });\n      });\n      items.push({ text: '-' });\n      var hasDictionarySupport = lastSuggestionsState.get().hasDictionarySupport;\n      if (hasDictionarySupport) {\n        items.push({\n          text: 'Add to Dictionary',\n          onclick: function () {\n            Actions.addToDictionary(editor, pluginUrl, startedState, textMatcherState, currentLanguageState, word, spans);\n          }\n        });\n      }\n      items.push.apply(items, [\n        {\n          text: 'Ignore',\n          onclick: function () {\n            Actions.ignoreWord(editor, startedState, textMatcherState, word, spans);\n          }\n        },\n        {\n          text: 'Ignore all',\n          onclick: function () {\n            Actions.ignoreWord(editor, startedState, textMatcherState, word, spans, true);\n          }\n        }\n      ]);\n      suggestionsMenu = global$5.create('menu', {\n        items: items,\n        context: 'contextmenu',\n        onautohide: function (e) {\n          if (e.target.className.indexOf('spellchecker') !== -1) {\n            e.preventDefault();\n          }\n        },\n        onhide: function () {\n          suggestionsMenu.remove();\n          suggestionsMenu = null;\n        }\n      });\n      suggestionsMenu.renderTo(domGlobals.document.body);\n      var pos = global$4.DOM.getPos(editor.getContentAreaContainer());\n      var targetPos = editor.dom.getPos(spans[0]);\n      var root = editor.dom.getRoot();\n      if (root.nodeName === 'BODY') {\n        targetPos.x -= root.ownerDocument.documentElement.scrollLeft || root.scrollLeft;\n        targetPos.y -= root.ownerDocument.documentElement.scrollTop || root.scrollTop;\n      } else {\n        targetPos.x -= root.scrollLeft;\n        targetPos.y -= root.scrollTop;\n      }\n      pos.x += targetPos.x;\n      pos.y += targetPos.y;\n      suggestionsMenu.moveTo(pos.x, pos.y + spans[0].offsetHeight);\n    };\n    var setup = function (editor, pluginUrl, lastSuggestionsState, startedState, textMatcherState, currentLanguageState) {\n      editor.on('click', function (e) {\n        var target = e.target;\n        if (target.className === 'mce-spellchecker-word') {\n          e.preventDefault();\n          var spans = Actions.findSpansByIndex(editor, Actions.getElmIndex(target));\n          if (spans.length > 0) {\n            var rng = editor.dom.createRng();\n            rng.setStartBefore(spans[0]);\n            rng.setEndAfter(spans[spans.length - 1]);\n            editor.selection.setRng(rng);\n            showSuggestions(editor, pluginUrl, lastSuggestionsState, startedState, textMatcherState, currentLanguageState, target.getAttribute('data-mce-word'), spans);\n          }\n        }\n      });\n    };\n    var SuggestionsMenu = { setup: setup };\n\n    global.add('spellchecker', function (editor, pluginUrl) {\n      if (DetectProPlugin.hasProPlugin(editor) === false) {\n        var startedState = Cell(false);\n        var currentLanguageState = Cell(Settings.getLanguage(editor));\n        var textMatcherState = Cell(null);\n        var lastSuggestionsState = Cell(null);\n        Buttons.register(editor, pluginUrl, startedState, textMatcherState, currentLanguageState, lastSuggestionsState);\n        SuggestionsMenu.setup(editor, pluginUrl, lastSuggestionsState, startedState, textMatcherState, currentLanguageState);\n        Commands.register(editor, pluginUrl, startedState, textMatcherState, lastSuggestionsState, currentLanguageState);\n        return Api.get(editor, startedState, lastSuggestionsState, textMatcherState, currentLanguageState, pluginUrl);\n      }\n    });\n    function Plugin () {\n    }\n\n    return Plugin;\n\n}(window));\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tinymce/plugins/spellchecker/plugin.js\n// module id = yTvn\n// module chunks = 10"],"sourceRoot":""}