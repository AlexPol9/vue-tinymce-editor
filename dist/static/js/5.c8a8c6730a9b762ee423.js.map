{"version":3,"sources":["webpack:///static/js/5.c8a8c6730a9b762ee423.js","webpack:///./~/tinymce/plugins/textpattern/index.js","webpack:///./~/tinymce/plugins/textpattern/plugin.js"],"names":["webpackJsonp","gvu3","module","exports","__webpack_require__","nGzP","domGlobals","__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","Plugin","Cell","initial","value","get","set","v","clone","global","tinymce","util","Tools","resolve","noop","constant","never","always","none","NONE","eq","o","isNone","call","thunk","id","n","me","fold","is","isSome","getOr","getOrThunk","getOrDie","msg","Error","getOrNull","getOrUndefined","undefined","or","orThunk","map","each","bind","exists","forall","filter","equals","equals_","toArray","toString","Object","freeze","some","constant_a","self","f","elementEq","b","from","Option","typeOf","x","t","prototype","isPrototypeOf","constructor","name","String","isFunction","type","nativeSlice","slice","xs","pred","len","push","sort","comparator","copy","hasOwnProperty","obj","key","has","isInlinePattern","pattern","isBlockPattern","isReplacementPattern","sortPatterns","patterns","start","createPatternSet","inlinePatterns","blockPatterns","replacementPatterns","get$1","patternsState","setPatterns","newPatterns","getPatterns","Api","defaultPatterns","end","format","cmd","getPatternSet","editorSettings","global$1","global$2","global$3","global$4","findPattern","text","indexOf","lastIndexOf","isMatchingPattern","offset","delta","substr","hasContent","findEndPattern","findInlinePattern","rng","space","collapsed","container","startContainer","data","nodeType","endPattern","startOffset","endOffset","patternRng","document","createRange","setStart","setEnd","startPattern","findReplacementPattern","startSearch","index","isText","node","setSelection","editor","textNode","newRng","dom","createRng","selection","setRng","splitContainer","splitText","deleteData","splitAndApply","found","inline","formatArray","isArray","grep","formatName","formatter","undoManager","transact","setCursorLocation","nextSibling","forEach","apply","applyInlinePattern","getRng","foundPattern","applyInlinePatternSpace","wrappedTextNode","lastChar","test","lastCharNode","doc","createTextNode","insertAfter","parentNode","applyInlinePatternEnter","applyBlockPattern","firstTextNode","textBlockElm","walker","isCollapsed","getParent","getStart","next","Math","max","trim","block","collapse","execCommand","selectionInsertText","string","insertData","newNode","insertNode","applyReplacement","target","match","insertContent","replacement","remove","extractChar","char","applyReplacementPattern","ch","applyReplacementPatternSpace","applyReplacementPatternEnter","handleEnter","patternSet","handleInlineKey","checkKeyEvent","codes","event","predicate","checkKeyCode","code","keyCode","modifierPressed","checkCharCode","chars","chr","charCodeAt","charCode","KeyHandler","setup","charCodes","keyCodes","on","e","setEditorTimeout","Keyboard","add","settings","window"],"mappings":"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","file":"static/js/5.c8a8c6730a9b762ee423.js","sourcesContent":["webpackJsonp([5],{\n\n/***/ \"gvu3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Exports the \"textpattern\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/textpattern')\n//   ES2015:\n//     import 'tinymce/plugins/textpattern'\n__webpack_require__(\"nGzP\");\n\n/***/ }),\n\n/***/ \"nGzP\":\n/***/ (function(module, exports) {\n\n(function () {\nvar textpattern = (function (domGlobals) {\n    'use strict';\n\n    var Cell = function (initial) {\n      var value = initial;\n      var get = function () {\n        return value;\n      };\n      var set = function (v) {\n        value = v;\n      };\n      var clone = function () {\n        return Cell(get());\n      };\n      return {\n        get: get,\n        set: set,\n        clone: clone\n      };\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    function __spreadArrays() {\n      for (var s = 0, i = 0, il = arguments.length; i < il; i++)\n        s += arguments[i].length;\n      for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n      return r;\n    }\n\n    var noop = function () {\n    };\n    var constant = function (value) {\n      return function () {\n        return value;\n      };\n    };\n    var never = constant(false);\n    var always = constant(true);\n\n    var none = function () {\n      return NONE;\n    };\n    var NONE = function () {\n      var eq = function (o) {\n        return o.isNone();\n      };\n      var call = function (thunk) {\n        return thunk();\n      };\n      var id = function (n) {\n        return n;\n      };\n      var me = {\n        fold: function (n, s) {\n          return n();\n        },\n        is: never,\n        isSome: never,\n        isNone: always,\n        getOr: id,\n        getOrThunk: call,\n        getOrDie: function (msg) {\n          throw new Error(msg || 'error: getOrDie called on none.');\n        },\n        getOrNull: constant(null),\n        getOrUndefined: constant(undefined),\n        or: id,\n        orThunk: call,\n        map: none,\n        each: noop,\n        bind: none,\n        exists: never,\n        forall: always,\n        filter: none,\n        equals: eq,\n        equals_: eq,\n        toArray: function () {\n          return [];\n        },\n        toString: constant('none()')\n      };\n      if (Object.freeze) {\n        Object.freeze(me);\n      }\n      return me;\n    }();\n    var some = function (a) {\n      var constant_a = constant(a);\n      var self = function () {\n        return me;\n      };\n      var bind = function (f) {\n        return f(a);\n      };\n      var me = {\n        fold: function (n, s) {\n          return s(a);\n        },\n        is: function (v) {\n          return a === v;\n        },\n        isSome: always,\n        isNone: never,\n        getOr: constant_a,\n        getOrThunk: constant_a,\n        getOrDie: constant_a,\n        getOrNull: constant_a,\n        getOrUndefined: constant_a,\n        or: self,\n        orThunk: self,\n        map: function (f) {\n          return some(f(a));\n        },\n        each: function (f) {\n          f(a);\n        },\n        bind: bind,\n        exists: bind,\n        forall: bind,\n        filter: function (f) {\n          return f(a) ? me : NONE;\n        },\n        toArray: function () {\n          return [a];\n        },\n        toString: function () {\n          return 'some(' + a + ')';\n        },\n        equals: function (o) {\n          return o.is(a);\n        },\n        equals_: function (o, elementEq) {\n          return o.fold(never, function (b) {\n            return elementEq(a, b);\n          });\n        }\n      };\n      return me;\n    };\n    var from = function (value) {\n      return value === null || value === undefined ? NONE : some(value);\n    };\n    var Option = {\n      some: some,\n      none: none,\n      from: from\n    };\n\n    var typeOf = function (x) {\n      if (x === null) {\n        return 'null';\n      }\n      var t = typeof x;\n      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n        return 'array';\n      }\n      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n        return 'string';\n      }\n      return t;\n    };\n    var isType = function (type) {\n      return function (value) {\n        return typeOf(value) === type;\n      };\n    };\n    var isFunction = isType('function');\n\n    var nativeSlice = Array.prototype.slice;\n    var filter = function (xs, pred) {\n      var r = [];\n      for (var i = 0, len = xs.length; i < len; i++) {\n        var x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    var sort = function (xs, comparator) {\n      var copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    var from$1 = isFunction(Array.from) ? Array.from : function (x) {\n      return nativeSlice.call(x);\n    };\n\n    var hasOwnProperty = Object.hasOwnProperty;\n    var get = function (obj, key) {\n      return has(obj, key) ? Option.from(obj[key]) : Option.none();\n    };\n    var has = function (obj, key) {\n      return hasOwnProperty.call(obj, key);\n    };\n\n    var isInlinePattern = function (pattern) {\n      return has(pattern, 'start') && has(pattern, 'end');\n    };\n    var isBlockPattern = function (pattern) {\n      return !has(pattern, 'end') && !has(pattern, 'replacement');\n    };\n    var isReplacementPattern = function (pattern) {\n      return has(pattern, 'replacement');\n    };\n    var sortPatterns = function (patterns) {\n      return sort(patterns, function (a, b) {\n        if (a.start.length === b.start.length) {\n          return 0;\n        }\n        return a.start.length > b.start.length ? -1 : 1;\n      });\n    };\n    var createPatternSet = function (patterns) {\n      return {\n        inlinePatterns: sortPatterns(filter(patterns, isInlinePattern)),\n        blockPatterns: sortPatterns(filter(patterns, isBlockPattern)),\n        replacementPatterns: filter(patterns, isReplacementPattern)\n      };\n    };\n\n    var get$1 = function (patternsState) {\n      var setPatterns = function (newPatterns) {\n        patternsState.set(createPatternSet(newPatterns));\n      };\n      var getPatterns = function () {\n        return __spreadArrays(patternsState.get().inlinePatterns, patternsState.get().blockPatterns, patternsState.get().replacementPatterns);\n      };\n      return {\n        setPatterns: setPatterns,\n        getPatterns: getPatterns\n      };\n    };\n    var Api = { get: get$1 };\n\n    var defaultPatterns = [\n      {\n        start: '*',\n        end: '*',\n        format: 'italic'\n      },\n      {\n        start: '**',\n        end: '**',\n        format: 'bold'\n      },\n      {\n        start: '***',\n        end: '***',\n        format: [\n          'bold',\n          'italic'\n        ]\n      },\n      {\n        start: '#',\n        format: 'h1'\n      },\n      {\n        start: '##',\n        format: 'h2'\n      },\n      {\n        start: '###',\n        format: 'h3'\n      },\n      {\n        start: '####',\n        format: 'h4'\n      },\n      {\n        start: '#####',\n        format: 'h5'\n      },\n      {\n        start: '######',\n        format: 'h6'\n      },\n      {\n        start: '1. ',\n        cmd: 'InsertOrderedList'\n      },\n      {\n        start: '* ',\n        cmd: 'InsertUnorderedList'\n      },\n      {\n        start: '- ',\n        cmd: 'InsertUnorderedList'\n      }\n    ];\n    var getPatternSet = function (editorSettings) {\n      var patterns = get(editorSettings, 'textpattern_patterns').getOr(defaultPatterns);\n      return createPatternSet(patterns);\n    };\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Delay');\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.util.VK');\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');\n\n    var global$4 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    var findPattern = function (patterns, text) {\n      for (var i = 0; i < patterns.length; i++) {\n        var pattern = patterns[i];\n        if (text.indexOf(pattern.start) !== 0) {\n          continue;\n        }\n        if (pattern.end && text.lastIndexOf(pattern.end) !== text.length - pattern.end.length) {\n          continue;\n        }\n        return pattern;\n      }\n    };\n    var isMatchingPattern = function (pattern, text, offset, delta) {\n      var textEnd = text.substr(offset - pattern.end.length - delta, pattern.end.length);\n      return textEnd === pattern.end;\n    };\n    var hasContent = function (offset, delta, pattern) {\n      return offset - delta - pattern.end.length - pattern.start.length > 0;\n    };\n    var findEndPattern = function (patterns, text, offset, delta) {\n      var pattern, i;\n      for (i = 0; i < patterns.length; i++) {\n        pattern = patterns[i];\n        if (pattern.end !== undefined && isMatchingPattern(pattern, text, offset, delta) && hasContent(offset, delta, pattern)) {\n          return pattern;\n        }\n      }\n    };\n    var findInlinePattern = function (patterns, rng, space) {\n      if (rng.collapsed === false) {\n        return;\n      }\n      var container = rng.startContainer;\n      var text = container.data;\n      var delta = space === true ? 1 : 0;\n      if (container.nodeType !== 3) {\n        return;\n      }\n      var endPattern = findEndPattern(patterns, text, rng.startOffset, delta);\n      if (endPattern === undefined) {\n        return;\n      }\n      var endOffset = text.lastIndexOf(endPattern.end, rng.startOffset - delta);\n      var startOffset = text.lastIndexOf(endPattern.start, endOffset - endPattern.end.length);\n      endOffset = text.indexOf(endPattern.end, startOffset + endPattern.start.length);\n      if (startOffset === -1) {\n        return;\n      }\n      var patternRng = domGlobals.document.createRange();\n      patternRng.setStart(container, startOffset);\n      patternRng.setEnd(container, endOffset + endPattern.end.length);\n      var startPattern = findPattern(patterns, patternRng.toString());\n      if (endPattern === undefined || startPattern !== endPattern || container.data.length <= endPattern.start.length + endPattern.end.length) {\n        return;\n      }\n      return {\n        pattern: endPattern,\n        startOffset: startOffset,\n        endOffset: endOffset\n      };\n    };\n    var findReplacementPattern = function (patterns, startSearch, text) {\n      for (var i = 0; i < patterns.length; i++) {\n        var index = text.lastIndexOf(patterns[i].start, startSearch);\n        if (index !== -1) {\n          return Option.some({\n            pattern: patterns[i],\n            startOffset: index\n          });\n        }\n      }\n      return Option.none();\n    };\n\n    var isText = function (node) {\n      return node && node.nodeType === 3;\n    };\n    var setSelection = function (editor, textNode, offset) {\n      var newRng = editor.dom.createRng();\n      newRng.setStart(textNode, offset);\n      newRng.setEnd(textNode, offset);\n      editor.selection.setRng(newRng);\n    };\n    var splitContainer = function (container, pattern, endOffset, startOffset) {\n      container = startOffset > 0 ? container.splitText(startOffset) : container;\n      container.splitText(endOffset - startOffset + pattern.end.length);\n      container.deleteData(0, pattern.start.length);\n      container.deleteData(container.data.length - pattern.end.length, pattern.end.length);\n      return container;\n    };\n    var splitAndApply = function (editor, container, found, inline) {\n      var formatArray = global$4.isArray(found.pattern.format) ? found.pattern.format : [found.pattern.format];\n      var validFormats = global$4.grep(formatArray, function (formatName) {\n        var format = editor.formatter.get(formatName);\n        return format && format[0].inline;\n      });\n      if (validFormats.length !== 0) {\n        editor.undoManager.transact(function () {\n          container = splitContainer(container, found.pattern, found.endOffset, found.startOffset);\n          if (inline) {\n            editor.selection.setCursorLocation(container.nextSibling, 1);\n          }\n          formatArray.forEach(function (format) {\n            editor.formatter.apply(format, {}, container);\n          });\n        });\n        return container;\n      }\n    };\n    var applyInlinePattern = function (editor, patterns, inline) {\n      var rng = editor.selection.getRng();\n      return Option.from(findInlinePattern(patterns, rng, inline)).map(function (foundPattern) {\n        return splitAndApply(editor, rng.startContainer, foundPattern, inline);\n      });\n    };\n    var applyInlinePatternSpace = function (editor, patterns) {\n      applyInlinePattern(editor, patterns, true).each(function (wrappedTextNode) {\n        var lastChar = wrappedTextNode.data.slice(-1);\n        if (/[\\u00a0 ]/.test(lastChar)) {\n          wrappedTextNode.deleteData(wrappedTextNode.data.length - 1, 1);\n          var lastCharNode = editor.dom.doc.createTextNode(lastChar);\n          editor.dom.insertAfter(lastCharNode, wrappedTextNode.parentNode);\n          setSelection(editor, lastCharNode, 1);\n        }\n      });\n    };\n    var applyInlinePatternEnter = function (editor, patterns) {\n      applyInlinePattern(editor, patterns, false).each(function (wrappedTextNode) {\n        setSelection(editor, wrappedTextNode, wrappedTextNode.data.length);\n      });\n    };\n    var applyBlockPattern = function (editor, patterns) {\n      var selection, dom, container, firstTextNode, node, format, textBlockElm, pattern, walker, rng, offset;\n      selection = editor.selection;\n      dom = editor.dom;\n      if (!selection.isCollapsed()) {\n        return;\n      }\n      textBlockElm = dom.getParent(selection.getStart(), 'p');\n      if (textBlockElm) {\n        walker = new global$3(textBlockElm, textBlockElm);\n        while (node = walker.next()) {\n          if (isText(node)) {\n            firstTextNode = node;\n            break;\n          }\n        }\n        if (firstTextNode) {\n          pattern = findPattern(patterns, firstTextNode.data);\n          if (!pattern) {\n            return;\n          }\n          rng = selection.getRng(true);\n          container = rng.startContainer;\n          offset = rng.startOffset;\n          if (firstTextNode === container) {\n            offset = Math.max(0, offset - pattern.start.length);\n          }\n          if (global$4.trim(firstTextNode.data).length === pattern.start.length) {\n            return;\n          }\n          if (pattern.format) {\n            format = editor.formatter.get(pattern.format);\n            if (format && format[0].block) {\n              firstTextNode.deleteData(0, pattern.start.length);\n              editor.formatter.apply(pattern.format, {}, firstTextNode);\n              rng.setStart(container, offset);\n              rng.collapse(true);\n              selection.setRng(rng);\n            }\n          }\n          if (pattern.cmd) {\n            editor.undoManager.transact(function () {\n              firstTextNode.deleteData(0, pattern.start.length);\n              editor.execCommand(pattern.cmd);\n            });\n          }\n        }\n      }\n    };\n    var selectionInsertText = function (editor, string) {\n      var rng = editor.selection.getRng();\n      var container = rng.startContainer;\n      if (isText(container)) {\n        var offset = rng.startOffset;\n        container.insertData(offset, string);\n        setSelection(editor, container, offset + string.length);\n      } else {\n        var newNode = editor.dom.doc.createTextNode(string);\n        rng.insertNode(newNode);\n        setSelection(editor, newNode, newNode.length);\n      }\n    };\n    var applyReplacement = function (editor, target, match) {\n      target.deleteData(match.startOffset, match.pattern.start.length);\n      editor.insertContent(match.pattern.replacement);\n      Option.from(target.nextSibling).filter(isText).each(function (nextSibling) {\n        nextSibling.insertData(0, target.data);\n        editor.dom.remove(target);\n      });\n    };\n    var extractChar = function (node, match) {\n      var offset = match.startOffset + match.pattern.start.length;\n      var char = node.data.slice(offset, offset + 1);\n      node.deleteData(offset, 1);\n      return char;\n    };\n    var applyReplacementPattern = function (editor, patterns, inline) {\n      var rng = editor.selection.getRng();\n      var container = rng.startContainer;\n      if (rng.collapsed && isText(container)) {\n        findReplacementPattern(patterns, rng.startOffset, container.data).each(function (match) {\n          var char = inline ? Option.some(extractChar(container, match)) : Option.none();\n          applyReplacement(editor, container, match);\n          char.each(function (ch) {\n            return selectionInsertText(editor, ch);\n          });\n        });\n      }\n    };\n    var applyReplacementPatternSpace = function (editor, patterns) {\n      applyReplacementPattern(editor, patterns, true);\n    };\n    var applyReplacementPatternEnter = function (editor, patterns) {\n      applyReplacementPattern(editor, patterns, false);\n    };\n\n    var handleEnter = function (editor, patternSet) {\n      applyReplacementPatternEnter(editor, patternSet.replacementPatterns);\n      applyInlinePatternEnter(editor, patternSet.inlinePatterns);\n      applyBlockPattern(editor, patternSet.blockPatterns);\n    };\n    var handleInlineKey = function (editor, patternSet) {\n      applyReplacementPatternSpace(editor, patternSet.replacementPatterns);\n      applyInlinePatternSpace(editor, patternSet.inlinePatterns);\n    };\n    var checkKeyEvent = function (codes, event, predicate) {\n      for (var i = 0; i < codes.length; i++) {\n        if (predicate(codes[i], event)) {\n          return true;\n        }\n      }\n    };\n    var checkKeyCode = function (codes, event) {\n      return checkKeyEvent(codes, event, function (code, event) {\n        return code === event.keyCode && global$2.modifierPressed(event) === false;\n      });\n    };\n    var checkCharCode = function (chars, event) {\n      return checkKeyEvent(chars, event, function (chr, event) {\n        return chr.charCodeAt(0) === event.charCode;\n      });\n    };\n    var KeyHandler = {\n      handleEnter: handleEnter,\n      handleInlineKey: handleInlineKey,\n      checkCharCode: checkCharCode,\n      checkKeyCode: checkKeyCode\n    };\n\n    var setup = function (editor, patternsState) {\n      var charCodes = [\n        ',',\n        '.',\n        ';',\n        ':',\n        '!',\n        '?'\n      ];\n      var keyCodes = [32];\n      editor.on('keydown', function (e) {\n        if (e.keyCode === 13 && !global$2.modifierPressed(e)) {\n          KeyHandler.handleEnter(editor, patternsState.get());\n        }\n      }, true);\n      editor.on('keyup', function (e) {\n        if (KeyHandler.checkKeyCode(keyCodes, e)) {\n          KeyHandler.handleInlineKey(editor, patternsState.get());\n        }\n      });\n      editor.on('keypress', function (e) {\n        if (KeyHandler.checkCharCode(charCodes, e)) {\n          global$1.setEditorTimeout(editor, function () {\n            KeyHandler.handleInlineKey(editor, patternsState.get());\n          });\n        }\n      });\n    };\n    var Keyboard = { setup: setup };\n\n    global.add('textpattern', function (editor) {\n      var patternsState = Cell(getPatternSet(editor.settings));\n      Keyboard.setup(editor, patternsState);\n      return Api.get(patternsState);\n    });\n    function Plugin () {\n    }\n\n    return Plugin;\n\n}(window));\n})();\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/5.c8a8c6730a9b762ee423.js","// Exports the \"textpattern\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/textpattern')\n//   ES2015:\n//     import 'tinymce/plugins/textpattern'\nrequire('./plugin.js');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tinymce/plugins/textpattern/index.js\n// module id = gvu3\n// module chunks = 5","(function () {\nvar textpattern = (function (domGlobals) {\n    'use strict';\n\n    var Cell = function (initial) {\n      var value = initial;\n      var get = function () {\n        return value;\n      };\n      var set = function (v) {\n        value = v;\n      };\n      var clone = function () {\n        return Cell(get());\n      };\n      return {\n        get: get,\n        set: set,\n        clone: clone\n      };\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    function __spreadArrays() {\n      for (var s = 0, i = 0, il = arguments.length; i < il; i++)\n        s += arguments[i].length;\n      for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n      return r;\n    }\n\n    var noop = function () {\n    };\n    var constant = function (value) {\n      return function () {\n        return value;\n      };\n    };\n    var never = constant(false);\n    var always = constant(true);\n\n    var none = function () {\n      return NONE;\n    };\n    var NONE = function () {\n      var eq = function (o) {\n        return o.isNone();\n      };\n      var call = function (thunk) {\n        return thunk();\n      };\n      var id = function (n) {\n        return n;\n      };\n      var me = {\n        fold: function (n, s) {\n          return n();\n        },\n        is: never,\n        isSome: never,\n        isNone: always,\n        getOr: id,\n        getOrThunk: call,\n        getOrDie: function (msg) {\n          throw new Error(msg || 'error: getOrDie called on none.');\n        },\n        getOrNull: constant(null),\n        getOrUndefined: constant(undefined),\n        or: id,\n        orThunk: call,\n        map: none,\n        each: noop,\n        bind: none,\n        exists: never,\n        forall: always,\n        filter: none,\n        equals: eq,\n        equals_: eq,\n        toArray: function () {\n          return [];\n        },\n        toString: constant('none()')\n      };\n      if (Object.freeze) {\n        Object.freeze(me);\n      }\n      return me;\n    }();\n    var some = function (a) {\n      var constant_a = constant(a);\n      var self = function () {\n        return me;\n      };\n      var bind = function (f) {\n        return f(a);\n      };\n      var me = {\n        fold: function (n, s) {\n          return s(a);\n        },\n        is: function (v) {\n          return a === v;\n        },\n        isSome: always,\n        isNone: never,\n        getOr: constant_a,\n        getOrThunk: constant_a,\n        getOrDie: constant_a,\n        getOrNull: constant_a,\n        getOrUndefined: constant_a,\n        or: self,\n        orThunk: self,\n        map: function (f) {\n          return some(f(a));\n        },\n        each: function (f) {\n          f(a);\n        },\n        bind: bind,\n        exists: bind,\n        forall: bind,\n        filter: function (f) {\n          return f(a) ? me : NONE;\n        },\n        toArray: function () {\n          return [a];\n        },\n        toString: function () {\n          return 'some(' + a + ')';\n        },\n        equals: function (o) {\n          return o.is(a);\n        },\n        equals_: function (o, elementEq) {\n          return o.fold(never, function (b) {\n            return elementEq(a, b);\n          });\n        }\n      };\n      return me;\n    };\n    var from = function (value) {\n      return value === null || value === undefined ? NONE : some(value);\n    };\n    var Option = {\n      some: some,\n      none: none,\n      from: from\n    };\n\n    var typeOf = function (x) {\n      if (x === null) {\n        return 'null';\n      }\n      var t = typeof x;\n      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n        return 'array';\n      }\n      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n        return 'string';\n      }\n      return t;\n    };\n    var isType = function (type) {\n      return function (value) {\n        return typeOf(value) === type;\n      };\n    };\n    var isFunction = isType('function');\n\n    var nativeSlice = Array.prototype.slice;\n    var filter = function (xs, pred) {\n      var r = [];\n      for (var i = 0, len = xs.length; i < len; i++) {\n        var x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    var sort = function (xs, comparator) {\n      var copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    var from$1 = isFunction(Array.from) ? Array.from : function (x) {\n      return nativeSlice.call(x);\n    };\n\n    var hasOwnProperty = Object.hasOwnProperty;\n    var get = function (obj, key) {\n      return has(obj, key) ? Option.from(obj[key]) : Option.none();\n    };\n    var has = function (obj, key) {\n      return hasOwnProperty.call(obj, key);\n    };\n\n    var isInlinePattern = function (pattern) {\n      return has(pattern, 'start') && has(pattern, 'end');\n    };\n    var isBlockPattern = function (pattern) {\n      return !has(pattern, 'end') && !has(pattern, 'replacement');\n    };\n    var isReplacementPattern = function (pattern) {\n      return has(pattern, 'replacement');\n    };\n    var sortPatterns = function (patterns) {\n      return sort(patterns, function (a, b) {\n        if (a.start.length === b.start.length) {\n          return 0;\n        }\n        return a.start.length > b.start.length ? -1 : 1;\n      });\n    };\n    var createPatternSet = function (patterns) {\n      return {\n        inlinePatterns: sortPatterns(filter(patterns, isInlinePattern)),\n        blockPatterns: sortPatterns(filter(patterns, isBlockPattern)),\n        replacementPatterns: filter(patterns, isReplacementPattern)\n      };\n    };\n\n    var get$1 = function (patternsState) {\n      var setPatterns = function (newPatterns) {\n        patternsState.set(createPatternSet(newPatterns));\n      };\n      var getPatterns = function () {\n        return __spreadArrays(patternsState.get().inlinePatterns, patternsState.get().blockPatterns, patternsState.get().replacementPatterns);\n      };\n      return {\n        setPatterns: setPatterns,\n        getPatterns: getPatterns\n      };\n    };\n    var Api = { get: get$1 };\n\n    var defaultPatterns = [\n      {\n        start: '*',\n        end: '*',\n        format: 'italic'\n      },\n      {\n        start: '**',\n        end: '**',\n        format: 'bold'\n      },\n      {\n        start: '***',\n        end: '***',\n        format: [\n          'bold',\n          'italic'\n        ]\n      },\n      {\n        start: '#',\n        format: 'h1'\n      },\n      {\n        start: '##',\n        format: 'h2'\n      },\n      {\n        start: '###',\n        format: 'h3'\n      },\n      {\n        start: '####',\n        format: 'h4'\n      },\n      {\n        start: '#####',\n        format: 'h5'\n      },\n      {\n        start: '######',\n        format: 'h6'\n      },\n      {\n        start: '1. ',\n        cmd: 'InsertOrderedList'\n      },\n      {\n        start: '* ',\n        cmd: 'InsertUnorderedList'\n      },\n      {\n        start: '- ',\n        cmd: 'InsertUnorderedList'\n      }\n    ];\n    var getPatternSet = function (editorSettings) {\n      var patterns = get(editorSettings, 'textpattern_patterns').getOr(defaultPatterns);\n      return createPatternSet(patterns);\n    };\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Delay');\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.util.VK');\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');\n\n    var global$4 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    var findPattern = function (patterns, text) {\n      for (var i = 0; i < patterns.length; i++) {\n        var pattern = patterns[i];\n        if (text.indexOf(pattern.start) !== 0) {\n          continue;\n        }\n        if (pattern.end && text.lastIndexOf(pattern.end) !== text.length - pattern.end.length) {\n          continue;\n        }\n        return pattern;\n      }\n    };\n    var isMatchingPattern = function (pattern, text, offset, delta) {\n      var textEnd = text.substr(offset - pattern.end.length - delta, pattern.end.length);\n      return textEnd === pattern.end;\n    };\n    var hasContent = function (offset, delta, pattern) {\n      return offset - delta - pattern.end.length - pattern.start.length > 0;\n    };\n    var findEndPattern = function (patterns, text, offset, delta) {\n      var pattern, i;\n      for (i = 0; i < patterns.length; i++) {\n        pattern = patterns[i];\n        if (pattern.end !== undefined && isMatchingPattern(pattern, text, offset, delta) && hasContent(offset, delta, pattern)) {\n          return pattern;\n        }\n      }\n    };\n    var findInlinePattern = function (patterns, rng, space) {\n      if (rng.collapsed === false) {\n        return;\n      }\n      var container = rng.startContainer;\n      var text = container.data;\n      var delta = space === true ? 1 : 0;\n      if (container.nodeType !== 3) {\n        return;\n      }\n      var endPattern = findEndPattern(patterns, text, rng.startOffset, delta);\n      if (endPattern === undefined) {\n        return;\n      }\n      var endOffset = text.lastIndexOf(endPattern.end, rng.startOffset - delta);\n      var startOffset = text.lastIndexOf(endPattern.start, endOffset - endPattern.end.length);\n      endOffset = text.indexOf(endPattern.end, startOffset + endPattern.start.length);\n      if (startOffset === -1) {\n        return;\n      }\n      var patternRng = domGlobals.document.createRange();\n      patternRng.setStart(container, startOffset);\n      patternRng.setEnd(container, endOffset + endPattern.end.length);\n      var startPattern = findPattern(patterns, patternRng.toString());\n      if (endPattern === undefined || startPattern !== endPattern || container.data.length <= endPattern.start.length + endPattern.end.length) {\n        return;\n      }\n      return {\n        pattern: endPattern,\n        startOffset: startOffset,\n        endOffset: endOffset\n      };\n    };\n    var findReplacementPattern = function (patterns, startSearch, text) {\n      for (var i = 0; i < patterns.length; i++) {\n        var index = text.lastIndexOf(patterns[i].start, startSearch);\n        if (index !== -1) {\n          return Option.some({\n            pattern: patterns[i],\n            startOffset: index\n          });\n        }\n      }\n      return Option.none();\n    };\n\n    var isText = function (node) {\n      return node && node.nodeType === 3;\n    };\n    var setSelection = function (editor, textNode, offset) {\n      var newRng = editor.dom.createRng();\n      newRng.setStart(textNode, offset);\n      newRng.setEnd(textNode, offset);\n      editor.selection.setRng(newRng);\n    };\n    var splitContainer = function (container, pattern, endOffset, startOffset) {\n      container = startOffset > 0 ? container.splitText(startOffset) : container;\n      container.splitText(endOffset - startOffset + pattern.end.length);\n      container.deleteData(0, pattern.start.length);\n      container.deleteData(container.data.length - pattern.end.length, pattern.end.length);\n      return container;\n    };\n    var splitAndApply = function (editor, container, found, inline) {\n      var formatArray = global$4.isArray(found.pattern.format) ? found.pattern.format : [found.pattern.format];\n      var validFormats = global$4.grep(formatArray, function (formatName) {\n        var format = editor.formatter.get(formatName);\n        return format && format[0].inline;\n      });\n      if (validFormats.length !== 0) {\n        editor.undoManager.transact(function () {\n          container = splitContainer(container, found.pattern, found.endOffset, found.startOffset);\n          if (inline) {\n            editor.selection.setCursorLocation(container.nextSibling, 1);\n          }\n          formatArray.forEach(function (format) {\n            editor.formatter.apply(format, {}, container);\n          });\n        });\n        return container;\n      }\n    };\n    var applyInlinePattern = function (editor, patterns, inline) {\n      var rng = editor.selection.getRng();\n      return Option.from(findInlinePattern(patterns, rng, inline)).map(function (foundPattern) {\n        return splitAndApply(editor, rng.startContainer, foundPattern, inline);\n      });\n    };\n    var applyInlinePatternSpace = function (editor, patterns) {\n      applyInlinePattern(editor, patterns, true).each(function (wrappedTextNode) {\n        var lastChar = wrappedTextNode.data.slice(-1);\n        if (/[\\u00a0 ]/.test(lastChar)) {\n          wrappedTextNode.deleteData(wrappedTextNode.data.length - 1, 1);\n          var lastCharNode = editor.dom.doc.createTextNode(lastChar);\n          editor.dom.insertAfter(lastCharNode, wrappedTextNode.parentNode);\n          setSelection(editor, lastCharNode, 1);\n        }\n      });\n    };\n    var applyInlinePatternEnter = function (editor, patterns) {\n      applyInlinePattern(editor, patterns, false).each(function (wrappedTextNode) {\n        setSelection(editor, wrappedTextNode, wrappedTextNode.data.length);\n      });\n    };\n    var applyBlockPattern = function (editor, patterns) {\n      var selection, dom, container, firstTextNode, node, format, textBlockElm, pattern, walker, rng, offset;\n      selection = editor.selection;\n      dom = editor.dom;\n      if (!selection.isCollapsed()) {\n        return;\n      }\n      textBlockElm = dom.getParent(selection.getStart(), 'p');\n      if (textBlockElm) {\n        walker = new global$3(textBlockElm, textBlockElm);\n        while (node = walker.next()) {\n          if (isText(node)) {\n            firstTextNode = node;\n            break;\n          }\n        }\n        if (firstTextNode) {\n          pattern = findPattern(patterns, firstTextNode.data);\n          if (!pattern) {\n            return;\n          }\n          rng = selection.getRng(true);\n          container = rng.startContainer;\n          offset = rng.startOffset;\n          if (firstTextNode === container) {\n            offset = Math.max(0, offset - pattern.start.length);\n          }\n          if (global$4.trim(firstTextNode.data).length === pattern.start.length) {\n            return;\n          }\n          if (pattern.format) {\n            format = editor.formatter.get(pattern.format);\n            if (format && format[0].block) {\n              firstTextNode.deleteData(0, pattern.start.length);\n              editor.formatter.apply(pattern.format, {}, firstTextNode);\n              rng.setStart(container, offset);\n              rng.collapse(true);\n              selection.setRng(rng);\n            }\n          }\n          if (pattern.cmd) {\n            editor.undoManager.transact(function () {\n              firstTextNode.deleteData(0, pattern.start.length);\n              editor.execCommand(pattern.cmd);\n            });\n          }\n        }\n      }\n    };\n    var selectionInsertText = function (editor, string) {\n      var rng = editor.selection.getRng();\n      var container = rng.startContainer;\n      if (isText(container)) {\n        var offset = rng.startOffset;\n        container.insertData(offset, string);\n        setSelection(editor, container, offset + string.length);\n      } else {\n        var newNode = editor.dom.doc.createTextNode(string);\n        rng.insertNode(newNode);\n        setSelection(editor, newNode, newNode.length);\n      }\n    };\n    var applyReplacement = function (editor, target, match) {\n      target.deleteData(match.startOffset, match.pattern.start.length);\n      editor.insertContent(match.pattern.replacement);\n      Option.from(target.nextSibling).filter(isText).each(function (nextSibling) {\n        nextSibling.insertData(0, target.data);\n        editor.dom.remove(target);\n      });\n    };\n    var extractChar = function (node, match) {\n      var offset = match.startOffset + match.pattern.start.length;\n      var char = node.data.slice(offset, offset + 1);\n      node.deleteData(offset, 1);\n      return char;\n    };\n    var applyReplacementPattern = function (editor, patterns, inline) {\n      var rng = editor.selection.getRng();\n      var container = rng.startContainer;\n      if (rng.collapsed && isText(container)) {\n        findReplacementPattern(patterns, rng.startOffset, container.data).each(function (match) {\n          var char = inline ? Option.some(extractChar(container, match)) : Option.none();\n          applyReplacement(editor, container, match);\n          char.each(function (ch) {\n            return selectionInsertText(editor, ch);\n          });\n        });\n      }\n    };\n    var applyReplacementPatternSpace = function (editor, patterns) {\n      applyReplacementPattern(editor, patterns, true);\n    };\n    var applyReplacementPatternEnter = function (editor, patterns) {\n      applyReplacementPattern(editor, patterns, false);\n    };\n\n    var handleEnter = function (editor, patternSet) {\n      applyReplacementPatternEnter(editor, patternSet.replacementPatterns);\n      applyInlinePatternEnter(editor, patternSet.inlinePatterns);\n      applyBlockPattern(editor, patternSet.blockPatterns);\n    };\n    var handleInlineKey = function (editor, patternSet) {\n      applyReplacementPatternSpace(editor, patternSet.replacementPatterns);\n      applyInlinePatternSpace(editor, patternSet.inlinePatterns);\n    };\n    var checkKeyEvent = function (codes, event, predicate) {\n      for (var i = 0; i < codes.length; i++) {\n        if (predicate(codes[i], event)) {\n          return true;\n        }\n      }\n    };\n    var checkKeyCode = function (codes, event) {\n      return checkKeyEvent(codes, event, function (code, event) {\n        return code === event.keyCode && global$2.modifierPressed(event) === false;\n      });\n    };\n    var checkCharCode = function (chars, event) {\n      return checkKeyEvent(chars, event, function (chr, event) {\n        return chr.charCodeAt(0) === event.charCode;\n      });\n    };\n    var KeyHandler = {\n      handleEnter: handleEnter,\n      handleInlineKey: handleInlineKey,\n      checkCharCode: checkCharCode,\n      checkKeyCode: checkKeyCode\n    };\n\n    var setup = function (editor, patternsState) {\n      var charCodes = [\n        ',',\n        '.',\n        ';',\n        ':',\n        '!',\n        '?'\n      ];\n      var keyCodes = [32];\n      editor.on('keydown', function (e) {\n        if (e.keyCode === 13 && !global$2.modifierPressed(e)) {\n          KeyHandler.handleEnter(editor, patternsState.get());\n        }\n      }, true);\n      editor.on('keyup', function (e) {\n        if (KeyHandler.checkKeyCode(keyCodes, e)) {\n          KeyHandler.handleInlineKey(editor, patternsState.get());\n        }\n      });\n      editor.on('keypress', function (e) {\n        if (KeyHandler.checkCharCode(charCodes, e)) {\n          global$1.setEditorTimeout(editor, function () {\n            KeyHandler.handleInlineKey(editor, patternsState.get());\n          });\n        }\n      });\n    };\n    var Keyboard = { setup: setup };\n\n    global.add('textpattern', function (editor) {\n      var patternsState = Cell(getPatternSet(editor.settings));\n      Keyboard.setup(editor, patternsState);\n      return Api.get(patternsState);\n    });\n    function Plugin () {\n    }\n\n    return Plugin;\n\n}(window));\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tinymce/plugins/textpattern/plugin.js\n// module id = nGzP\n// module chunks = 5"],"sourceRoot":""}